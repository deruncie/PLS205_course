---
title: "Lab 8 Supplement: RCBD with random blocks and replicates"
output:
  html_notebook:
    toc: true
    toc_float: true 
---


## RCBD with random blocks and replicates
Three varieties of wheat were tests for yield across a random sample of five fields in the Central Valley. 
Each variety was planted in three plots on each field.

The goal was to make recomendations for the best variety across the whole valley.

```{r}
variety_data = read.csv('Var_trial.csv')
str(variety_data)
```

### Model table

**Design**: RCBD with random blocks and replicates of treatments in blocks

| Structure | Variable      | Type        | # levels | Experimental Unit |
|-----------|---------------|-------------|----------|-------------------|
| Treatment | Variety       | Categorical | 3        | ?                 |
| Design    | Field         | Categorical | 5        |                   |
|           | Variety:Field | Categorical | 15       |                   |
|           | Plot          | Categorical | 45       |                   |
| Response  | Yield         | Numeric     | 45       |                   |

Most of this table is a straight-forward RCBD or Factorial table. 

However, note that unlike a typical RCBD, there are several replicates of each variety in each block (Field)

We can see that with the `table` function
```{r}
table(variety_data$Field,variety_data$Variety)
```

#### Check the data!
Always be sure to compare the **Type** and **# levels** from your table to your data.

Note that Field was read in as an `int`, not a `Categorical` variable. We need to fix this.

```{r}
variety_data$Field <- as.factor(variety_data$Field)
str(variety_data)
```

We also don't have a column for *Plot* in the data, but we do have *Rep*. We can check what *Rep* means
with `table`
```{r}
table(variety_data$Rep,variety_data$Field,variety_data$Variety)
```

In this output, there's a table for each of the 3 varieties. Rows are *Rep* and columns are *Field*.
We can see that there is a Rep 1, 2, and 3 for each *Var* in each *Field*. 
So *Rep* is nested inside *Field:Var*, and provides an index for our *Plot*.


### What is the experimental unit for Variety?

> Look back at the Model table. I didn't fill in the Experimental Unit for Variety here

We have two choices: *Plot*, or *Field:Variety*

#### 1. EU = Plot
If we were interested in only these fields, we would choose *Plot* as the experimental unit.

Then, we would study the interaction between Field and Variety, and decide if the Variety differences 
were different in any of these fields.

If we reported the main effect of Variety, we would interpret it as the *average* differences among the Varieties
*in these 5 fields*.

#### 2. EU = Field:Variety
But, we are interested in extrapolating to all fields in the Central Valley.

This means that we want to report the average differences among the varieties in *any* field, not just these 5.

To know this, we need to measure the Varieties in several fields. We've measured each variety in 5 fields,
so we have 5 experimental units per Variety.

> How are these experimental units identified in our data?

We need a way to refer to each experimental unit for each Variety. This is simply *Variety:Field*,
the specific combinations of Variety and Field. Our table lists 15 levels of this term (5/variety).

### Thought Experiment
Say due to technical restrictions, we were only able to plant a single variety in each Field.
We still use 3 plots/field, but now we use 15 Fields so that each Variety is still planted in 5 fields.

> Questions:
>
> What is the Experimental Unit for Variety?
> Will this experiment have greater or lesser power than the original experiment? Why?
>   Consider: # replicates / Variety, sources of variation among experimental units.

### Plot of data
Let's visualize our data. We do this like a RCBD or Factorial:
```{r}
library(ggplot2)
# first get the block means
block_means = aggregate(yield~Field,variety_data,FUN=mean)
# order the table of block_means
block_means = block_means[order(block_means$yield),]
block_means
variety_data$Field = factor(variety_data$Field,levels = block_means$Field)
ggplot(variety_data,aes(x=Field,y=yield)) + ylab('Variety mean yield') +
  stat_summary(aes(group=Variety,color=Variety),fun.y = mean,geom='line') # This calculates the mean of each Var in each Field, and connects them with a line
  # The points to connect is specified with "group = Var". The values to average are the combinations of group and x.
```

We see that the Field 1 is much better and Field 5 much worse than the others. 
Differences among varieties seem to vary some across field (Var:Field interactions.)


### Write the model
To form the linear model for this experiment, we first note if we have any terms that must be declared *Random*

In this experiment, since our goal is to extrapolate to all fields, the term *Field:Variety* is an Experimental Unit for *Variety*
and must be declared Random.

In this case, it would make sense to also declare *Field* to be Random, since we ideally would have
sampled fields randomly from all available Central Valley fields. But it WON'T MATTER, since *Field* is not an experimental unit!

> Try it either way to convince yourself of this!

The linear model for this experiment, with the goal of extrapolating to all fields would be written as:

```{r}
variety_model = lmer(yield ~ Variety + (1|Field) + (1|Variety:Field),variety_data)
```

As usual, we don't list the observational unit - *Plot* (or any random effects confounded with it) as terms in the model. 
This effect is assumed by R.

### Model diagnostics.
As with the CRD with sub-samples, we need to check more assumptions with this model.

We need to check assumptions for *all Experimental Units* in the model.

For the *Variety:Field* terms (ie Experimental Units for Variety).
For this, we can only look at the qqplot and the S/L plots.
Note, the code for extracting the experimental units estimates is a bit more involved here (line 163)
```{r}

# Step 1: Extract estimates of the experimental unit deviations
eu_data = aggregate(yield ~ Variety+Field,variety_data,FUN = mean)
  # this is like above - we're generating a new table with one row per plot
  # you'll have to adapt this for other experiments with other Variables
eu_data$deviation = ranef(variety_model)$`Variety:Field`[interaction(eu_data$Variety,eu_data$Field,drop=TRUE),1] 
  # The key above is to substitute `Plot` for the name of your random experimental unit term above in both places
eu_data$fitted = predict(variety_model,newdata = eu_data,re.form = ~0)
  # This line you can use directly

# Step 2: Make QQplot and `Scale-Location` plot:
op = par(mfrow=c(1,2))  # two plots side-by-side
qqPlot(eu_data$deviation,main = 'Plot (EU) Normal Q-Q',pch=19)  # new qqplot function
scatter.smooth(eu_data$fitted,sqrt(abs(eu_data$deviation)),span = 1,main = 'Scale-Location',ylab = expression(sqrt(abs(' deviations '))),xlab = 'Fitted values')
```

> all diagnostics look fine.

### Analysis
Now that we have fit our model, the analysis follows as normal for an RCBD:

ANOVA:
```{r}
anova(variety_model,ddf='K')
```

> Note: we have only 8 degrees of freedom for error (DenDF). Why?

Pairwise comparisons among varieties:
```{r}
variety_means = emmeans(variety_model,specs = 'Variety',lmer.df = 'K')
variety_effects = contrast(variety_means,method='pairwise')
summary(variety_effects,infer=T)
```

> We can distinguish Var3 from Var1 at alpha = 0.05, but all confidence intervals are pretty large.


### Exercise:
Repeate the analysis above, but as a Factorial.

```{r}

```

> What is the experimental Unit?
> Are there any terms that need to be declared Random?
> You should now be able to also distinguish Var2 from Var3 at alpha = 0.05. Why?
